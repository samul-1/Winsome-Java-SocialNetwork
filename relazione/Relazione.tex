\documentclass[a4paper,8pt]{article} % Prepara un documento per carta A4, con un font di dimensione 12pt

\usepackage[italian]{babel} % Adatta LaTeX alle convenzioni tipografiche italiane,
% e ridefinisce alcuni titoli in italiano, come "Capitolo" al posto di "Chapter",
% se il vostro documento è in italiano
% l'opzione  linguistica 'french' è necessaria per l'abilitazione della
% successiva istruzione <<\frenchspacing>> 
\usepackage[T1]{fontenc} % Riga da togliere se si compila con PDFLaTeX
\usepackage[utf8]{inputenc} % Consente l'uso caratteri accentati italiani
\usepackage{amsthm}
\usepackage[margin=1.1in]{geometry}
\usepackage{hyperref}
\usepackage{ragged2e}
\RaggedRight

\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{hyperref}

\setlist[enumerate]{label*=\arabic*.}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
}


\lstset{style=mystyle}

\def\code#1{\texttt{#1}}
\title{Progetto di laboratorio di reti} % \LaTeX è una macro che compone il logo "LaTeX"
% I commenti (introdotti da %) vengono ignorati

\author{Samuele Bonini}
\date{}
% in alternativa a \date il comando \today introduce la data di sistema.

\begin{document}


\maketitle % Genera il titolo sulle istruzioni  \title, \author e \date



\tableofcontents % Prepara l'indice generale
\setlength{\parskip}{0.5em}

\section{Architettura di massima del progetto} %
\subsection{Suddivisione in layer}
Nella realizzazione del software in oggetto, si è scelto di utilizzare un'architettura a strati, suddividendo le classi in gioco
all'interno di insiemi disgiunti in base alle responsabilità e alle dipendenze. Lo scopo di utilizzare layer ben distinti è quello
di ottenere un basso grado di accoppiamento tra le componenti del sistema, mantenendo altresì una buona  \emph{separation of concerns}.
Avere un basso grado di accoppiamento tra le classi implica la possibilità di sviluppare in maniera quanto più indipendente
le varie componenti, modificandole (o anche riscrivendole da zero) all'occorrenza, oltre che avere un vantaggio nelle fasi di testing e debugging, ove è
più facile isolare eventuali fault.
\par
In seguito all'analisi dei requisiti, in fase di progettazione sono stati definiti i seguenti layer:
\begin{itemize}
    \item \textbf{Entità}: sono le classi che rappresentano il dominio dell'applicazione e incarnano l'universo delineato dal progetto
    \item \textbf{Data store}: espone le entità al mondo esterno attraverso un'interfaccia controllata e definisce le operazioni primitive sulle stesse
    \item \textbf{Business logic}: implementa operazioni più complesse servendosi dalle primitive esposte dallo store e, talvolta, dalle entità stesse;
          aggiunge controlli di vario tipo (permessi, \emph{well-formedness} delle richieste, ecc.); fornisce all'esterno un'API più ricca per interagire con le entità
    \item \textbf{Server}: gestisce la connessione logica coi client, espone un'API per accedere ai layer sottostanti secondo le regole di business, si occupa della
          formattazione e presentazione dei dati in entrata e in uscita
\end{itemize}
La regola generale è che le classi di un layer hanno dipendenze solo da classi dello stesso layer o di layer più interni (\emph{inward dependency principle}).
Si noti infine che i nomi dei layer sopracitati non sono in corrispondenza biunivoca coi package Java utilizzati nel progetto, i quali sono stati
identificati con un criterio differente e più legato ai dettagli implementativi.
\par(img)

\par Questo documento è strutturato in maniera tale da illustrare, come prima cosa, le caratteristiche delle entità
di dominio e quali sono le operazioni primitive a esse associate, per poi spostarsi progressivamente sui layer
più esterni dell'architettura, dando un'idea di come le classi appartenenti allo strato della business logic sono
implementate, chiarendo infine come viene realizzata, agli atti, la comunicazione tra il server e il client.\\
\subsection{Protocollo applicazione}
Il protocollo utilizzato a livello applicativo è HTTP. Il server espone un'API di tipo REST misto a RPC. Le richieste e le risposte HTTP vengono
rispettivamente incarnate dalle classi \code{RestRequest} e \code{RestResponse}, che dispongono di metodi per convertirle da (risp. in) stringhe, consentendone
la (de)serializzazione e lettura (risp. scrittura) mediante socket.
\par L'autenticazione utilizza il protocollo \textbf{bearer token}, schema definito nell'\href{https://datatracker.ietf.org/doc/html/rfc6750}{RFC 6750}.
Il protcollo prevede che le richieste vengano autenticate inserendo un header (\code{Authorization}) contenente un token di 128 bit.
La classe \code{AuthenticationMiddleware} (spiegata più in dettaglio nel seguito), responsabile della verifica delle credenziali nelle richieste HTTP,
controlla la presenza e la validità di questo header.
\par Il token viene ottenuto per la prima volta dal client in fase di login: la password fornita dall'utente all'atto della registrazione, che viene mantenuta
nel database criptata utilizzando l'algoritmo \href{https://en.wikipedia.org/wiki/MD5}{MD5}, viene confrontata con quella inviata durante il login (dopo aver
cifrato anch'essa); in caso di esito positivo, il server emette un token che l'utente utilizzerà nelle successive richieste (fino al logout).


\section{Le entità di dominio}
\subsection{Gli utenti}
La classe \code{User} rappresenta un utente registrato a Winsome. A esso è associato uno username, una password (criptata come descritto nel capitolo precedente) e un \code{Set} di tag,
rappresentati da stringhe \emph{lowercase}. L'univocità dello username non è gestita a livello entità ma nello store.
\subsection{Post, commenti, reazioni}
La classe \code{Post} rappresenta un post all'interno di Winsome. Contiene informazioni circa il titolo, il contenuto e il timestamp di creazione. L'identificativo del post è uno UUID.
\par Il post contiene una stringa che si riferisce allo username del suo autore. La scelta di utilizzare una stringa anziché un riferimento a un oggetto \code{User} deriva dalla volontà
di gestire l'integrità referenziale a livello di store anziché all'interno delle entità stesse: si è scelto, in altre parole, di non utilizzare l'\textbf{active record pattern}, in favore
della presenza di un layer dedicato all'accesso ai dati.
\par I commenti e le reazioni (upvote o downvote) ai post vengono aggregati all'interno di due insiemi presenti nella classe. La scelta di utilizzare un \code{TreeSet} per entrambi deriva
dalla necessità di mantenere l'ordine temporale di inserimento.
\par Infine, i post contengono opzionalmente un riferimento a un altro post: ciò viene utilizzato per implementare la feature di \textbf{rewin}. Questo permette, in principio (anche se non
presente in quanto fuori dai limiti delle specifiche), di effettuare il \emph{rewinning} di un post aggiungendo anche un testo come contenuto del post, come un "commento in evidenza" (feature presente,
per esempio, nei retweet, a cui il rewin si ispira).
\subsection{Serializer}
La classe \code{Serializer<T>} è responsabile delle operazioni di serializzazione e de-serializzazione delle entità.
L'utilizzo del polimorfismo parametrico permette di (de)serializzare tutte le classi che lo necessitano con un singolo metodo per operazione, senza ri-definirne
la logica.
\par Internamente, la classe utilizza la libreria Jackson e l'\code{ObjectMapper}. Le entità da (de)serializzare sono annotate, all'occorrenza, con le \emph{annotations} del pacchetto
\code{jackson.annotation} per avere un controllo più fine su quali proprietà e campi vengono serializzati.


\section{Il data store}
La classe \code{DataStoreService} implementa il data access layer. Essa costituisce un'astrazione posta sopra al sistema di storage sottostante, qualunque esso sia
(in questo caso, come richiesto dalla specifica, si utilizza il filesystem e file in formato JSON, ma la presenza di questo layer permetterebbe, se necessario, di cambiare lo storage system
utilizzando, per esempio, un DBMS, senza alterare il resto del progetto).
\par Lo store gestisce gran parte della concorrenza all'interno del progetto: incapsulando l'accesso concorrente ai dati in una sola classe,
è possibile sviluppare il layer della business logic in maniera prevalentemente \textbf{thread-unaware}, il che semplifica fortemente l'implementazione e suddivide meglio le responsabilità.
\subsection{Strutture dati}
La scelta delle strutture dati segue il criterio di \textbf{indicizzazione} dei dati per consentire una migliore performance nei lookup e nelle scritture. Questo significa che la \emph{ratio} dietro
la presenza di strutture dati che apprentemente portano a ridondanza (e talvolta a una riduzione del grado di normalizzazione dei dati) è quella di ottimizzare le operazioni sui dati più comuni.
\par Lo strumento principale per gestire la concorrenza è l'utilizzo della \code{ConcurrentHashMap} di Java. L'utilizzo delle varianti del metodo \code{compute} della struttura in questione garantisce l'atomicità
delle operazioni e pertanto la consitenza dei dati. In pochi casi (come la cancellazione di un post, in seguito alla quale è necessario cancellare anche eventuali rewin del post), viene ammessa una breve finestra
all'interno della quale la consistenza è compromessa: questo pattern è conosciuto come \emph{eventual consistency} e trova ragion d'essere nell'obiettivo di compromettere la performance il meno possibile, specialmente
in operazioni dove la temporanea perdita di consistenza non appare avere effetti negativi rilevanti sul modo in cui l'utente percepisce lo stato del sistema.

\par All'interno dello store si trovano le seguenti mappe:
\begin{itemize}
    \item \code{users}: mappa username su istanze della classe \code{User}; è il metodo principale per reperire un utente
    \item \code{userPosts}: mappa username su insiemi di post (viene utilizzato un \code{TreeSet} per garantire l'ordinamento cronologico consistente); utilizzata per avere un accesso rapido ai post quando vengono cercati per autore
    \item \code{sessions}: mappa token di autenticazione su utenti; utilizzata per autenticare gli utenti in base al valore del campo header \code{Authorization}
    \item \code{posts}: mappa UUID su istanze di \code{Post}; utilizzata per cercare post per ID
    \item \code{followers}: mappa username su insiemi di username; mantiene le relazioni di follower tra gli utenti
    \item \code{wallets}: mappa username su portafogli (si veda il paragrafo sulla classe \code{Wallet})
    \item \code{notificationCallbacks}: mappa username su \code{IClientFollowerNotificationService}; utilizzata per reperire l'istanza del client per il servizio di notifica dei follower via RMI callback
\end{itemize}
\subsection{Persistenza dello stato}
Al momento dell'istanziazione, la classe \code{DataStoreService} inizializza un thread demone che, periodicamente, effettua il salvataggio dello stato dello store.
Il salvataggio avviene mediante una serializzazione dell'istanza dello store e successiva scrittura su un file indicato al momento della creazione dell'istanza.
La classe espone altresì il metodo statico \code{restoreOrCreate} che, passato il nome di un file JSON, tenta di ripristinare lo stato a partire da quel file, deserializzandolo e, in caso
di impossibilità di completare l'operazione (file inesistente o malformato), restituisce una nuova istanza dello store.


\section{Il business logic layer}
Lo strato dei servizi/business logic fornisce all'esterno un'interfaccia mediante la quale implementa tutte le operazioni che devono essere esposte all'utente.
\subsection{La classe SocialNetworkService}
La classe \code{SocialNetworkService} implementa le operazioni associate alle route dell'API REST/RPC.\\ I metodi handler presenti in questa classe
sono in corrispondenza biunivoca con i path dell'API (si veda capitolo sul router).

\par In generale, un handler è una funzione che prende come parametro un oggetto di tipo \code{RestRequest} e restituisce una \code{RestResponse}. Al suo interno,
ha luogo la logica di business come la validazione dei parametri della richiesta, il controllo dei permessi, il \emph{dispatching} delle azioni richieste verso il data store, e la
serializzazione dei dati in uscita per la costruzione della risposta.

\par Gli handler restituiscono direttamente una \code{RestResponse} solo nel caso in cui l'esecuzione abbia successo. Se si verifica un errore, i metodi in questione non restituiscono
direttamente una risposta (per esempio \code{4xx}) ma sollevano un'eccezione. La gestione degli errori in fase di gestione di una richiesta viene così demandata
al server (come illustrato nel relativo capitolo), il quale invierà una risposta HTTP contente l'errore appropriato.
\par Questa strategia, ispirata al modo in cui il framework \href{https://www.djangoproject.com/}{Django} gestisce gli errori nelle sue \emph{views}, serve ad astrarre ulteriormente i casi in cui la richiesta non ha successo:
anziché avere il codice per la gestione degli errori sparpagliato (e duplicato) tra i vari handler, essi si limitano a lanciare un'eccezione che viene catturata e gestita in una singola locazione.
Così diventa
facile, per esempio, aggiungere qualsiasi tipo di logica \emph{custom} per la gestione degli errori. Si pensi per esempio all'aggiunta di un sistema di logging: basterebbe chiamare il metodo esposto dal servizio nel singolo spot in cui
viene catturata l'eccezione.

\par La classe \code{SocialNetworkService} è prettamente \emph{stateless}: le chiamate ai metodi al suo interno causano cambiamenti nello stato gestito dallo store, ma la classe
in sé non contiene stato interno. Questo permette, in principio, sia di utilizzare la classe come un \emph{singleton} (come viene effettivamente fatto), oppure di scalarla
orizzontalmente, dislocando più istanze di essa su diversi nodi worker (nel caso di un sistema distribuito), a patto di mantenere un riferimento allo store centralizzato.

\subsection{La classe RewardIssuer}
La classe \code{SocialNetworkService} realizza il servizio di ricompense di Winsome. Implementa l'interfaccia \code{Runnable} e una singola istanza di essa viene creata dal server al momento dell'avvio ed eseguita in un thread.
Nel suo metodo \code{run}, la classe entra in un ciclo infinito, all'interno del quale attende via \code{Thread.sleep} il tempo stabilito nel file di configurazione del server, per poi chiamare un metodo che calcola
le nuove ricompense per tutti gli utenti.
\par Il calcolo sui singoli post viene effettuato secondo la formula data dalla specifica. Per reperire i dati necessari al calcolo, il reward issuer si serve di una classe \emph{helper} interna, \code{PostRewardData}: in essa,
vengono aggregati i dati necessari all'applicazione della formula a un singolo post, nonché al corretto assegnamento delle ricompense ai curatori. In particolare, la classe contiene l'insieme di: utenti che hanno messo un \emph{upvote}
dall'ultimo calcolo delle ricompense, utenti che hanno commentato dall'ultima iterazione, nuovi commenti e nuove reazioni.
\par Una volta completato il calcolo delle ricompense, viene aggiornato un campo nella classe che tiene traccia del timestamp dell'ultimo calcolo ricompense e viene inviata una notifica multicast mediante un \code{DatagramSocket}.

\subsection{La classe WalletConversionService}
La classe \code{WalletConversionService} è responsabile per la simulazione del cambio nel tasso di conversione tra Wincoin e Bitcoin.
Per ottenere un tasso casuale, viene effettuata una richiesta HTTP all'API di \href{https://random.org}{random.org}. La richiesta è autenticata mediante l'utilizzo di una \code{apiKey}, come spiegato nella
\href{https://api.random.org/json-rpc/4/basic}{documentazione dell'API di random.org}. La richiesta viene scritta utilizzando un \code{writer} di tipo \code{DataOutputStream}. La successiva risposta viene letta
con un \code{BufferedReader} e passata a uno \code{StringBuilder}. La stringa risultante viene parsata per verificare che l'interazione abbia avuto successo ed estrarre il valore casuale restituito dal servizio remoto.

\par Dato che il servizio remoto potrebbe, in generale, non essere disponibile, la classe è dotata di un \textbf{circuit breaker} allo scopo di migliorare la disponibilità del servizio.
L'idea è la seguente: quando una richiesta ha successo, il valore restituito da random.org viene salvato in una variabile interna che svolge la funzione di cache.\\
Nel caso in cui una successiva richiesta fallisca,
il servizio proverà periodicamente a ricontattare il server remoto fino a raggiungere il numero \code{MAX\_RETRIES} di tentativi. A quel punto, il circuit breaker verrà attivato. L'effetto risultante è che il valore in cache verrà
restituito e, per un periodo di tempo pari a \code{CIRCUIT\_BREAKER\_COOL\_DOWN} secondi, tutte le richieste al servizio restituiranno immediatamente il valore in cache, senza provare a contattare l'API di random.org.
\par L'impiego di questo pattern, comune in architetture a microservizi e sistemi distribuiti in genere, serve a minimizzare il numero di richieste inviate durante un periodo in cui il servizio remoto è, con alta probabilità (dato che le richieste recenti hanno dato esito negativo), ancora non raggiungibile.

\par La classe viene utilizzata come \emph{singleton} ma, a differenza di \code{SocialNetworkService}, contiene stato interno (il valore \emph{cached} e i dati del circuit breaker).
Per permettere la condivisione fra thread della singola istanza di questa classe, le parti di codice dove lo stato interno viene acceduto sono protette da monitor (mediante il costrutto \code{synchronized}).

\subsection{I servizi di registrazione utente e notifica}\quad \\




\section{L'API e il router}
La gestione delle richieste da parte del server segue un pattern simile al \textbf{model-view-controller} (MVC).
I \emph{model} sono rappresentati in maniera naturale dalle entità di dominio e gli handler della classe \code{SocialNetworkService} costituiscono
le \emph{views}. Il router rappresenta il \emph{controller}, ovvero il componente che mappa le coppie $<path, metodo>$ su handler dell'API.

\subsection{La classe ApiRoute}
La classe \code{ApiRoute} rappresenta una route dell'API e i metodi handler a essa associati. Contiene un campo stringa rappresentante il path e una \code{Map}
che associa metodi HTTP a stringhe che rappresentano nomi di metodi (spiegato più in dettaglio nel seguito).

\subsection{La classe ApiRouter}
All'avvio del server, viene istanziato un \code{ApiRouter}, il quale carica in memoria degli oggetti \code{ApiRoute} deserializzandoli da un file JSON.
\par La respnsabilità del router è quella di risolvere i path richiesti restituendo un riferimento all'appropriato metodo handler per la richiesta.
Contiene un metodo principale, \code{getRequestHandler}, che prende in ingresso una \code{RestRequest}.
Il metodo si occupa di estrarre il path e il metodo HTTP della richiesta e di cercare un match all'interno del suo insieme di route.
\par Se si ha una corrispondenza (ovvero è associato il nome di un metodo handler alla coppia\\ $<path, metodo>$),
viene restituito il riferimento a un metodo della classe \code{SocialNetworkService}, che verrà poi invocato coi corretti parametri per
soddisfare la richiesta (si veda capitolo successivo per il flusso completo).
\par Il meccanismo appena descritto utilizza la classe Java \href{https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html}{Method},
collocata nel pacchetto\\ \code{java.lang.reflect}.
\par Si è scelto di utilizzare questo approccio (anziché, per esempio, un controllo \code{switch} sul path della richiesta) per ottenere una dichiarazione \textbf{descrittiva} (e non imperativa) dell'API:
avere la definizione delle route in un file JSON e non nel codice stesso permette di ottenere un basso grado di accoppiamento tra la logica e la descrizione dell'interfaccia; si pensi per
esempio all'aggiunta di un nuovo \emph{entry point} nell'API: se la descrizione dell'interfaccia fosse contenuta nel codice, la modifica allo schema richiederebbe anche una modifica al codice del router,
mentre con questo tipo di definizione è sufficiente aggiornare il file JSON contenente lo schema dell'API (dopo aver, eventualmente, implementato il nuovo handler).



\section{Il server}

\subsection{Funzionamento e gestione delle connessioni}
Il modello utilizzato per l'implementazione del server è il multiplexing dei canali via \code{Selector} NIO con l'impiego una threadpool per la gestione delle richieste.
All'avvio il server, dopo aver aperto un \code{ServerSocketChannel} e aver esportato gli stub necessari per l'esposizione dei servizi basati su RMI,
entra in un ciclo infinito.
\par All'interno del ciclo, il server utilizza un \code{Selector} per accettare nuove connessioni e richieste.
Quando un client diventa \emph{readable}, viene chiamato sulla sua key corrispondente il metodo \code{readFromKey}. Al suo interno, viene letta la richiesta inviata dal client,
la quale viene poi gestita secondo il flusso descritto nel \hyperref[sec:http_flow]{prossimo paragrafo}.

\par Il task della gestione della richiesta viene sottomesso a un \code{ExecutorService}, permettendo al thread principale di continuare ad accettare richieste mentre gli worker gestiscono quelle già prese in carico.
Per la sottomissione delle richieste al pool viene utilizzata la classe \href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html}{\code{CompletableFuture}}.
\par Per prima cosa, il metodo \code{handleRequest} (che si occupa materialmente della gestione della richiesta) viene passato come callback al metodo \code{supplyAsync} della classe \code{CompletableFuture}.
Questo fa sì che il task venga sottomesso al pool \code{ForkJoinPool.commonPool}, che è gestito internamente dalla JVM ed è ottimizzato con la tecnica del \href{https://en.wikipedia.org/wiki/Work_stealing}{\emph{work stealing}} per massimizzare l'efficienza e l'utilizzo dei thread.
Al completamento del task da parte di un worker, viene chiamato il callback passato al metodo \code{thenAccept}: questa funzione lambda prende come argomento la \code{RestResponse} restituita dalla gestione della richiesta e la salva nell'\emph{attachment} associato al client.
Dopodiché, le \code{interestOps} della key del client vengono impostate in modo da tenere traccia di quando il client diventerà \emph{writable}.

\par Una volta verificatosi questo evento, il metodo \code{writeToKey} viene chiamato e causa la scrittura della risposta precedentemente generata sul socket associato al client. Al termine della scrittura, le \code{interestOps} della key in questione
vengono nuovamente settate in modo da tracciare la \emph{readability}.

\subsection{Gestione di una richiesta HTTP}
\label{sec:http_flow}

Dopo aver letto dal socket e ricostruito una \code{RestRequest} inviata da un client, il flusso di gestione della richiesta da parte del server si compone dei seguenti passi:
\begin{enumerate}
    \item Il path e metodo della richiesta vengono utilizzati per cercare una corrispondenza nel router.
          \begin{enumerate}
              \item Se il path non dà corrispondenza, viene restituito l'errore 404. Se il metodo non dà corrispondenza, viene restituito l'errore 405. Se il lookup ha successo, viene reperito il riferimento al metodo handler appropriato.
          \end{enumerate}
    \item L'\code{AuthenticationMiddleware} analizza gli header della richiesta alla ricerca del token nel campo \code{Authorization}. Questo controllo viene omesso in fase di login.
          \begin{enumerate}
              \item Se il token non è presente, viene restituito l'errore 401. Se il token è invalido, viene restituito l'errore 400. Se la verifica ha successo, la richiesta viene autenticata (incapsulandola in una \code{AuthenticatedRestRequest}) e associata all'utente corrispondente al token.
          \end{enumerate}
    \item L'handler restituito al punto 1 viene invocato passandogli la richiesta autenticata del punto 2.
          \begin{enumerate}
              \item Se si verifica un errore all'interno dello handler, l'eccezione viene catturata come\\ \code{InvocationTargetException}. La tecnica di \emph{exception chaining} permette di estrarre l'eccezione originale
                    sollevata dallo handler e di inviare in risposta l'errore appropriato. Qualsiasi altro tipo di eccezione sollevata non direttamente dallo handler causa l'emissione di un errore 500. Se l'esecuzione ha successo, lo handler restituisce una \code{RestResponse}.
          \end{enumerate}
    \item La risposta viene salvata nell'\emph{attachment} associato al client e verrà scritta sul socket corrispondente quando il client diventa \emph{writable}.
\end{enumerate}
(img)\\


\subsection{La classe ServerConfig}\quad \\

\section{Il client CLI}

\subsection{Gestione di una richiesta al server}\quad \\
\subsection{Rendering dei dati}\quad \\
\subsection{Gestione dei messaggi}\quad \\

\section{Il client GUI}

\subsection{Realizzazione.}\quad \\
\subsection{Limitazioni.}\quad \\


\end{document}
